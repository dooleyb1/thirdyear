
==================== FINAL INTERFACE ====================
2018-11-27 19:16:44.16977 UTC

interface prfch_3yIeWdQAfX8DVUb2gN9xHL:Check 7103
  interface hash: 58de81cd968c2834a8c645e6fefe5474
  ABI hash: beb495fcb643ef320a9363a690ef146b
  export-list hash: 260c24fc8b191e13daaaa0adc7041b33
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 4c0a7b65a6dddbc4161c2e2bfabe3dc3
  sig of: Nothing
  used TH splices: False
  where
exports:
  Check.checkTheorem
  Check.showReport
  Check.Report
module dependencies: AST HParse Matching Theory Utilities
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0 containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      haskell-src-1.0.2.0@haske_L5FnTXYimTzE7JszPj0uf6
                      integer-gmp-1.0.0.0 pretty-1.1.2.0@prett_JItwetRppk1H5Uq3xbjDGC
                      syb-0.6@syb_4kccWaTe3QZLxAMQYKgEyE
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
         syb-0.6@syb_4kccWaTe3QZLxAMQYKgEyE:Data.Generics.Instances
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
                         pretty-1.1.2.0@prett_JItwetRppk1H5Uq3xbjDGC:Text.PrettyPrint.HughesPJ
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.OldList d8fd80b0e14aa085ce6219cd89dad356
import  -/  base-4.8.2.0:Data.Tuple 012ad951a59a9d85fe1de36a2f012986
import  -/  base-4.8.2.0:Debug.Trace 6660afb6094d69397ea084364da8f950
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:System.IO 0899686bfc1d9ef72dff3de85e99862a
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  AST 8a2c29d575e8bd3b64abf6366ce4d014
  exports: d301949d97205237750d6e196e86b7e3
  App 16928c931d42832910f90887747c0486
  Bind 1a817160d5a378c2b4d953792a592ee5
  Decl 325c8d65ca514c7fe46d5a8a76c991a1
  Equal 9ab5005624b07fc046792a0c4bdc517b
  Expr 325c8d65ca514c7fe46d5a8a76c991a1
  Fun b691abc4dc5624d7de3dc48974e26943
  GrdExpr 4ad9c2ef324f99a63e6dbe045daa87b5
  If bfa6eeddaa6092d9cfb287d5418c7f36
  InfixApp fbca351163cfd9526df4f211979540ad
  LBool e264df423fd015fab52602374903c239
  LChar 4cc92b6079b6162415116e9dbfb9d0c9
  LInt 1f5a2ded06047cc65711d6521cb50d18
  Let 042391980ce15c2122c7472e7a3cf1ea
  Mdl 3a580753785869f650971d478fdab68d
  PApp b3fda5fdcafbf3e7ac9c102bbf180324
  Var 8f32eb9b8c2cb1cf31bdb89ed88c3cae
  eEq e0c2d4cd6008c66de717977d5cca551b
  fname e482605a8ea255c9a7405a5dfd35224c
  ldecls d45ab09571e98e34be3a16bf8bec4b37
  lhspat f2c7166637fd4bb40e7ca80992690ab5
  rhs 0e3a6f348d5aa068c15344ad05dcdc36
  topdecls 840e8705d1be0eff9dd14a3cc2a91009
import  -/  Matching 4337ae5eedd456eb3a53c0c9a3d8b38f
  exports: 4cae086bd8bb86072f6134b6a7c3c0b5
  buildReplacement 506774137fe257b6e9c1986f36739adc
  eMatch 9fd09a11d4e70c517e4895f030dcaa52
import  -/  Theory 945be06abe503e01076baa0b98b5ab10
  exports: 846a3dbe26a72e2c5e47a867ef999f4f
  At bd87584c0ba61220bba4030987a935d2
  BECAUSE ae92c3bcd5bfe0f65767f9da0bff0016
  CALC f29b7245ccdc74ac252292498ed7d74b
  Calculation cfedafbf8ac37dfe9953e203ea617cbf
  D 46400ad089c812712f8baad5a491ce5c
  Focus 06cdb153e96a621e1231a98b6348fbec
  IH 84feb08549b7bfe9fa89b82b2433ffd2
  Justification 9fb398a2d4d5431d4425dabff5ee01b9
  L c7bf73cf78adcb7838fa5bd6bad4dc99
  L2R a2bd0e898bd0e9abc6215361193fdb33
  LAW b94ae3d6ed9d686ceb06708c50834779
  Law a941c025b2cb90eaaa807693ab089d0c
  R2L 5ffe6b85e5a047cd6e7f3e853aec1c84
  ReduceAll 0b4acfa28353a198a83b81d1a1f7febd
  ReduceBoth 7064711cd1965061c36b8903d9267d6f
  ReduceLHS 2228ede68ce9f9bc8a81b55dc9df6cb9
  ReduceRHS aaaddcca1d43338e28cf0f7701044faf
  SMP dd6357b4c8f3a6cfd7f1628e54ccb8ab
  Strategy 4f5a33fddad632d48359401d308703c3
  Theorem 3fd49cf6767e49588e214e1f58198a02
  Theory b9686a1808a31bd14ddb9b050635ef72
  Top 7749e78be2d04cd12267d50e789997d3
  Usage 106be8dcba0fa471969adf639abc45c5
  Whole 125f3fb54658e61e9a00edc8d4475645
  assume c9c4e90ea77a17fc2f776ceba688c821
  bGoal 755468344254d9b76a5f31de18c72028
  baseStrategy b24650d4ea527862a99feabf0fb58bb3
  iGoal 94a9916e13a1ad2d27739893e3cd45cb
  iVar 51558ec96715b03273eee04700aff808
  indType a834efa171e5aa9de4cd46db48a51bd6
  lawEqn 52adfeeda58690c6854dd376ad3d29ba
  lawName 93711316b35ad1b5ffc9bea1b3d727aa
  stepStrategy 940907f05a1e2c1f82fc69312f60aa94
  strategy a654f75d3ba0578292484a6ac763c8e4
  thIndScheme cb8852c60bf61daab2766bb138d89126
  thLaws f5bcaeb0208b2f21266adc42c3bdb48d
  theorem 67cbe9e1aaa272cb7320e12a7a6d2892
  thmName 8deeb588d90832ae0a23787866befca9
bafff7df2a4f49d60a78f1ee8ba67771
  $fEqExprBranches :: GHC.Classes.Eq Check.ExprBranches
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Check.ExprBranches
                  Check.$fEqExprBranches_$c==
                  Check.$fEqExprBranches_$c/= -}
bafff7df2a4f49d60a78f1ee8ba67771
  $fEqExprBranches_$c/= ::
    Check.ExprBranches -> Check.ExprBranches -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a1 :: Check.ExprBranches b :: Check.ExprBranches ->
                 case a1 of wild {
                   Check.AppB
                   -> case b of wild1 {
                        Check.AppB -> GHC.Types.False Check.OtherB -> GHC.Types.True }
                   Check.OtherB
                   -> case b of wild1 {
                        Check.AppB -> GHC.Types.True
                        Check.OtherB -> GHC.Types.False } }) -}
bafff7df2a4f49d60a78f1ee8ba67771
  $fEqExprBranches_$c== ::
    Check.ExprBranches -> Check.ExprBranches -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Check.ExprBranches ds1 :: Check.ExprBranches ->
                 case ds of wild {
                   Check.AppB
                   -> case ds1 of wild1 {
                        Check.AppB -> GHC.Types.True Check.OtherB -> GHC.Types.False }
                   Check.OtherB
                   -> case ds1 of wild1 {
                        Check.AppB -> GHC.Types.False
                        Check.OtherB -> GHC.Types.True } }) -}
bafff7df2a4f49d60a78f1ee8ba67771
  $fShowExprBranches :: GHC.Show.Show Check.ExprBranches
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Check.ExprBranches
                  Check.$fShowExprBranches_$cshowsPrec
                  Check.$fShowExprBranches_$cshow
                  Check.$fShowExprBranches_$cshowList -}
bafff7df2a4f49d60a78f1ee8ba67771
  $fShowExprBranches1 :: Check.ExprBranches -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Check.ExprBranches eta :: GHC.Base.String ->
                 case ds of wild {
                   Check.AppB
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Check.$fShowExprBranches3)
                        eta
                   Check.OtherB
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Check.$fShowExprBranches2)
                        eta }) -}
6b8fe6a5a440cffdf6e9cb7c09e47609
  $fShowExprBranches2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OtherB"#) -}
5b92c0fa28e894c06800d393dd0360f1
  $fShowExprBranches3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "AppB"#) -}
bafff7df2a4f49d60a78f1ee8ba67771
  $fShowExprBranches_$cshow :: Check.ExprBranches -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Check.ExprBranches ->
                 case x of wild {
                   Check.AppB -> Check.$fShowExprBranches3
                   Check.OtherB -> Check.$fShowExprBranches2 }) -}
bafff7df2a4f49d60a78f1ee8ba67771
  $fShowExprBranches_$cshowList ::
    [Check.ExprBranches] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Check.ExprBranches
                   Check.$fShowExprBranches1) -}
bafff7df2a4f49d60a78f1ee8ba67771
  $fShowExprBranches_$cshowsPrec ::
    GHC.Types.Int -> Check.ExprBranches -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int
                   ds1 :: Check.ExprBranches
                   eta :: GHC.Base.String ->
                 case ds1 of wild {
                   Check.AppB
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Check.$fShowExprBranches3)
                        eta
                   Check.OtherB
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Check.$fShowExprBranches2)
                        eta }) -}
eb8c3eb1ef04175c37433fa5db6fe8fe
  type Branch = (GHC.Types.Int, Check.ExprBranches)
b01ab781d2347db73bc2d35e2b64226e
  type Definition = (AST.Expr, AST.Expr, [AST.Decl])
bafff7df2a4f49d60a78f1ee8ba67771
  data ExprBranches = AppB | OtherB
    Promotable
1ad0a00554c3e57f90b34d22809e05de
  type Path = [Check.Branch]
e1cfff989cc435cd63b5ef62ca6b8281
  type Report = [GHC.Base.String]
f0d0d82f95328fbfc5d7787e524dca5c
  checkStrategy ::
    [AST.Mdl]
    -> [Theory.Theory]
    -> AST.Expr
    -> AST.Expr
    -> Theory.Strategy
    -> Check.Report
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><S,1*U> -}
d6c50f301585bc3dab0a7e72abe3914f
  checkTheorem ::
    [AST.Mdl] -> [Theory.Theory] -> Theory.Theorem -> Check.Report
  {- Arity: 3, Strictness: <L,U><L,U><L,U(1*U,1*U,1*U)>,
     Unfolding: (\ mdls :: [AST.Mdl]
                   thrys :: [Theory.Theory]
                   thm :: Theory.Theorem ->
                 GHC.Base.++
                   @ [GHC.Types.Char]
                   (Data.OldList.lines
                      (GHC.CString.unpackAppendCString#
                         "\n\
                         \Checking theorem '"#
                         (case thm of wild { Theory.THEOREM ds1 ds2 ds3 ->
                          GHC.Base.++ @ GHC.Types.Char ds1 Check.checkTheorem2 })))
                   (case thm of wild { Theory.THEOREM ds1 ds2 ds3 ->
                    Check.checkStrategy mdls thrys Check.dummyH ds2 ds3 })) -}
392a0f13506c7471677bdf50cfddaa34
  checkTheorem1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "??"#) -}
62c7070f101f2c49fc56aaeadf82400c
  checkTheorem2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "'"#) -}
dfdc3e7688391a919ccd6e1174a81b07
  dummyH :: AST.Expr
  {- Strictness: m4, Unfolding: (AST.Var Check.checkTheorem1) -}
c801230892e7d4924abafb30ae4dfc7e
  showReport :: [GHC.Base.String] -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,1*U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Check.showReport1
                  `cast`
                (<[GHC.Base.String]>_R ->_R Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
b6525eebb62a17d452fe605568911c9d
  showReport1 ::
    [GHC.Base.String]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ rep :: [GHC.Base.String]
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   (Data.OldList.unlines rep)
                   GHC.Types.True
                   eta) -}
instance GHC.Classes.Eq [Check.ExprBranches]
  = Check.$fEqExprBranches
instance GHC.Show.Show [Check.ExprBranches]
  = Check.$fShowExprBranches
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

